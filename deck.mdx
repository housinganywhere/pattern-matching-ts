import { Head } from 'mdx-deck'

export { default as theme } from './theme'

<Head>
  <title>Pattern matching in TS</title>
</Head>

# Pattern matching in TS

---

## What's pattern matching?

```notes
It makes sense to start defining what is it
```

---

```reason
let str = "hola";

let result =
  switch(str) {
  | "hola" => "HOLA"
  | "chau" => "bye!"
  | _      => "..."
  };
```

```notes
Many languages have it.

In reason it's called `switch`.
```

---

```scala
import scala.util.Random

val x: Int = Random.nextInt(10)

x match {
  case 0 => "zero"
  case 1 => "one"
  case 2 => "two"
  case _ => "many"
}
```

```notes
In Scala it's called `match`
```

---

```scala
sealed abstract class Furniture
case class Couch() extends Furniture
case class Chair() extends Furniture

def findPlaceToSit(piece: Furniture): String = piece match {
  case a: Couch => "Lie on the couch"
  case b: Chair => "Sit on the chair"
}
```

```notes
Also works on types (classes)
```

---

```csharp
public static double ComputeAreaModernSwitch(object shape)
{
    switch (shape)
    {
        case Square s:
            return s.Side * s.Side;
        case Circle c:
            return c.Radius * c.Radius * Math.PI;
        case Rectangle r:
            return r.Height * r.Length;
        default:
            throw new ArgumentException(
                message: "shape is not a recognized shape",
                paramName: nameof(shape));
    }
}
```

```notes
C# (not only FP langs)
```

---

```go
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\\n", v)
	}
}
```

```notes
Go has something for types
```

---

```rust
let x = Some(5);
let y = 10;

match x {
    Some(50) => println!("Got 50"),
    Some(y)  => println!("Matched, y = {:?}", y),
    _        => println!("Default case, x = {:?}", x),
}
```

```notes
Rust
```

---

```elm
num : Int
num = 1

result : String
result = 
  case num of
    1 -> "one"
    2 -> "two"
    _ -> "other"
```

```notes
`case x of` in Elm and Haskell
```

---

```haskell
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
```

<a href="https://bit.ly/2TPWg57" target="_blank">Source</a>

```notes
Haskell also supports pattern matching on the function parameters.

Combined with destructuring it results in very declarative functions.
```

---

```elm
type alias State = Int

type Action = Inc | Dec

reducer : State -> Action -> State
reducer state action =
  case action of
    Inc -> state + 1
    Dec -> state - 1
```

```notes
We can also pattern match on Algebraic Data Types

(i.e. custom types / union types)
```

---

```elm
type alias State = Int

type Action
  = Inc
  | Dec
  | Add Int

reducer : State -> Action -> State
reducer state action =
  case action of
    Inc   -> state + 1
    Dec   -> state - 1
    Add x -> state + x
```

```notes
This is the end goal !!!
```

---

## What about JavScript and TypeScript?

```notes
This is all cool but we write JavaScript !!!
```

---

## We can only hope ...

<https://github.com/tc39/proposal-pattern-matching>

---

```js
const res = await fetch(jsonService)
case (res) {
  when {status: 200, headers: {'Content-Length': s}} -> {
    console.log(`size is ${s}`)
  }
  when {status: 404} -> {
    console.log('JSON not found')
  }
  when {status} if (status >= 400) -> {
    throw new RequestError(res)
  }
}
```

---

```jsx
<Fetch url={API_URL}>{
  props => case (props) {
    when {loading} -> <Loading />
    when {error} -> <Error error={error} />
    when {data} -> <Page data={data} />
    when _ -> throw new Error('badmatch')
  }
}
</Fetch>
```

---

## On the mean time ...

<img src="https://media1.giphy.com/media/1rOUXIDg1XaHSdlLxZ/giphy.gif?cid=3640f6095c620b1b4758337167e5f390" />

```notes
It seems cool! So what can we do now?

They don't support pattern matching "per se" ...

BUT !!! 
```

---

```js
const fn = R.cond([
  [R.equals(0),   R.always('water freezes at 0°C')],
  [R.equals(100), R.always('water boils at 100°C')],
  [R.T,           t => `nothing special happens at ${t}°C`],
])

fn(0)   // => 'water freezes at 0°C'
fn(50)  // => 'nothing special happens at 50°C'
fn(100) // => 'water boils at 100°C'
```

<https://ramdajs.com/docs/#cond>

```notes
Yeah, Ramda, of course

- NOT type safe
- Already useful, but still limited
```

---

```js
// static/js/ui/Chip.js

const createIcon = R.cond([
  [React.isValidElement, R.identity],
  [R.is(String), name => <SvgIcon name={name} />],
  [R.is(Object), props => <SvgIcon {...props} />],
  [R.T, () => null],
])
```

---

## Many approaches

(list them)

<https://blog.carbonfive.com/2018/01/08/an-introduction-to-adts-and-structural-pattern-matching-in-typescript>
<https://pattern-matching-with-typescript.alabor.me>
<https://blog.logrocket.com/pattern-matching-and-type-safety-in-typescript-1da1231a2e34>
<https://blog.parametricstudios.com/posts/pattern-matching-custom-data-types>

```notes
I'm not the first one to talk about this

Of course !!!

But I'm not satisfied =/

TOO much boilerplate, more than acceptable
```

---

```ts
import match from '@housinganywhere/match'

type Variant =
  | 'success'
  | 'danger'
  | 'warning'

const variantColor = match<Variant, string>({
  success: () => 'green',
  danger: () => 'red',
  warning: () => 'yellow',
})
```

<https://github.com/housinganywhere/match>

```notes
Et voilà !
```

---

```ts
import { wildMatch } from '@housinganywhere/match';

type Vowels = 'a' | 'e' | 'i' | 'o' | 'u';

const isA = wildMatch<Vowels, string>({
  a: () => 'Yay!',
  _: (v) => `Nope, "${v}" is not "a"`,
});
```

```notes
This one is not published yet ...

What about the name ?
```

---

```jsx
type PayoutTypes = 'iban' | 'bank' | 'paypal'

const PayoutMethod = ({ payoutMethod, payoutType }) => 
  <div>
    {match<PayoutTypes, React.ReactNode>({
      iban: () => (
        <IbanMethod method={payoutMethod} isNew={!payoutMethod} />
      ),
      bank: () => (
        <BankMethod method={payoutMethod} isNew={!payoutMethod} />
      ),
      paypal: () => (
        <PaypalMethod method={payoutMethod} isNew={!payoutMethod} />
      ),
    })(payoutType)}
  </div>
```

```notes
`match` and `wildMatch` are generic

Still limiting !!!

What about pattern matching on data ?
```

---

```ts
type Matcher<T extends string, R> = { [K in T]: (k: K) => R };

const match = <T extends string, R = void>(m: Matcher<T, R>) => (t: T) => m[t](t);
```

```notes
Yeah, implementation is that simple !!!
```
---

```ts
type PartialMatcher<T extends string, R> =
  { [K in T]?: (k: K) => R } & { _: (t: T) => R; };

const wildMatch = <T extends string, R = void>(m: PartialMatcher<T, R>) => (t: T) => {
  const f = m[t];
  if (f) {
    return f(t);
  }

  return m._(t);
};
```

```notes
Even the `wildMatch` one is very simple!

This gives already and idea of what we can do
to get the data in the `case` function.
```

---

<iframe
  src="https://codesandbox.io/embed/o9y2mrx5k9"
  style={{ width:'95vw', height: '95vh', border: 0, borderRadius: 4, overflow:'hidden' }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

```notes
TODO: build from scratch !!!!

Already have the API but not the implementation !!!
```

---

```ts
type RemoteData<D, E> =
  | NotAsked
  | Loading
  | Success<D>
  | Failure<E>
```

<https://github.com/gillchristian/remote-data-ts>

---

```ts
const renderArticle = cata<Article, string, React.ReactNode>({
  notAsked: () => <Idle />,
  loading: () => <Spinner />,
  success: (article) => <Article {...article} />,
  error: (msg) => <Msg variant="danger">{msg}</Msg>,
})
```

---

<iframe
  src="https://codesandbox.io/embed/kx6q84nk5o"
  style={{ width:'95vw', height: '95vh', border: 0, borderRadius: 4, overflow:'hidden' }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

---

<https://housinganywhere.com>

<https://github.com/gillchristian>

---

# THE END
